# Vue 源码

## 1

### 1.1 router 钩子.[src/views/HomeView.vue](../../public/example/1.vue3.base/src/views/HomeView.vue)

```vue
<template>
  <div class="home">
    <img alt="Vue logo" src="../assets/logo.png" />
    <HelloWorld msg="Welcome to Your Vue.js App" />
  </div>
</template>

<script>
// @ is an alias to /src
import HelloWorld from '@/components/HelloWorld.vue'

export default {
  name: 'HomeView',
  components: {
    HelloWorld,
  },
  // async
  beforeRouteLeave(to, from, next) {
    console.log('组件内的离开')
    // await new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     if (Math.random() > 0.5) {
    //       next()
    //     }
    //   }, 1000)
    // })
  },
  beforeRouteUpdate() {
    console.log('组件内的更新')
  },
}
</script>
```

### 1.2 router 钩子.[src/views/MyView.vue](../../public/example/1.vue3.base/src/views/MyView.vue)

```vue
<template>
  <div class="about">
    <h1>my a</h1>

    <router-link to="/my/a">a路径</router-link>
    <router-link to="/my/b">b路径</router-link>
    <router-view></router-view>
  </div>
</template>
<script>
export default (await import('vue')).defineComponent({
  beforeRouteLeave() {
    console.log('my-leave')
  },
})
</script>
```

### 1.3 router 钩子.test.[src/vue-router/createRouter.js](../../public/example/1.vue3.base/src/vue-router/createRouter.js)

```js
export function createRouter({ history, routes }) {
  // 路由匹配：根据路径进行匹配
  const matcher = createRouterMatcher(routes)
  // 1. 需要响应式；2. 解构后响应式存在；3. 内部数组元素非响应式；
  const currentLocation = shallowRef(START_LOCATION)

  let ready
  function markReady() {
    if (ready) return
    ready = true
    history.listen((to, from) => {
      to = matcher.resolve(to)
      from = currentLocation.value
      finalNavigation(to, from)
    })
  }
  function finalNavigation(to, from) {
    // 判断 replace 还是 push
    if (from === START_LOCATION) {
      history.replace(to.path)
    } else {
      history.push(to.path)
    }
    currentLocation.value = to // 更新路径
    markReady()
  }

  function extractRecords(to, from) {
    const leavingRecords = []
    const updatingRecords = []
    const enteringRecords = []
    let len = Math.max(to.matched.length, from.matched.length) // 哪个匹配多，哪个为准；
    for (let i = 0; i < len; i++) {
      const fromRecord = from.matched[i]
      if (fromRecord) {
        if (to.matched.find((record) => record.path === fromRecord.path)) {
          updatingRecords.push(fromRecord)
        } else {
          leavingRecords.push(fromRecord)
        }
      }
      const toRecord = to.matched[i]
      if (toRecord) {
        if (!from.matched.find((record) => record.path === toRecord.path)) {
          enteringRecords.push(toRecord)
        }
      }
    }
    return [leavingRecords, updatingRecords, enteringRecords]
  }

  // my -> beforeRouteleave my/a -> beforeRouteleave
  function guardToPromise(guard, to, from, record) {
    return () =>
      new Promise((resolve, reject) => {
        // 返回函数的目的：可以组合多个 guard
        const next = resolve
        const r = guard.call(record, to, from, next)
        Promise.resolve(r).then(next) // 等待 guard 执行完毕后自动调用 next
      })
  }

  function extractGuards(guardType, matched, to, from) {
    let guards = []
    for (let record of matched) {
      let comp = record.components.default
      const guard = comp[guardType]
      guard && guards.push(guardToPromise(guard, to, from))
    }
    return guards
  }

  function runGuardQueue(guards) {
    return guards.reduce(
      (promise, guard) => promise.then(() => guard()),
      Promise.resolve()
    )
  }

  function navigate(to, from) {
    const [leavingRecords, updatingRecords, enteringRecords] = extractRecords(
      to,
      from
    )

    let guards = extractGuards(
      'beforeRouteLeave',
      leavingRecords.reverse(),
      to,
      from
    )
    return runGuardQueue(guards)
      .then(() => {
        guards = []
        for (let guard of beforeGuards.list()) {
          guards.push(guardToPromise(guard))
        }
        return runGuardQueue(guards) // 全局钩子
      })
      .then(() => {
        let guards = extractGuards(
          'beforeRouteUpdate',
          updatingRecords.reverse(),
          to,
          from
        )
        return runGuardQueue(guards)
      })
      .then(() => {
        guards = []
        for (let record of to.matched) {
          const enterGuard = record.beforeEnter
          if (enterGuard) {
            guards.push(guardToPromise(enterGuard))
          }
        }
        return runGuardQueue(guards)
      })
      .then(() => {
        guards = extractGuards('beforeRouteEnter', enteringRecords)
        return runGuardQueue(guards)
      })
      .then(() => {
        guards = []
        for (let guard of beforeResolveGuards.list()) {
          guards.push(guardToPromise(guard))
        }
        return runGuardQueue(guards) // 全局钩子
      })
    // 这里需要将函数组合起来执行 compose
  }

  function pushWithRedirect(to) {
    const from = currentLocation.value
    to = matcher.resolve(to.value || to)
    // 有 to 和 from 监控路径的变化，后续可以更新路径
    // 跳转路由+监听
    navigate(to, from)
      .then(() => {
        return finalNavigation(to, from)
      })
      .then(() => {
        for (let guard of afterGuards.list()) {
          guard(to, from)
        }
      })
  }
  function push(to) {
    return pushWithRedirect(to)
  }
  if (currentLocation.value === START_LOCATION) {
    // 第一次加载路由，根据路径找到组件将他放入到 START_LOCATION 中
    push(history.location) // 默认的跳转
  }

  function useCallbacks() {
    const handlers = [] // 用户函数
    const add = (handler) => handlers.push(handler)
    return {
      add,
      list: () => handlers,
    }
  }

  const beforeGuards = useCallbacks()
  const beforeResolveGuards = useCallbacks()
  const afterGuards = useCallbacks()

  // 当用户访问： /my/a -> { path: '/my/a', matched: [ my, my/a ] }
  const router = {
    push,
    install(app) {
      app.provide('router', router)
      let reactiveObj = {}
      for (let key in START_LOCATION) {
        reactiveObj[key] = computed(() => currentLocation.value[key])
      }
      app.provide('location', reactive(reactiveObj))
      // 核心注册两个组件
      app.component('RouterLink', RouterLink)
      app.component('RouterView', RouterView)
      // 让所有的子组件可以获取到路由 provide globalProperties
    },
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
  }
  return router
}
```

### 1.4 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 1.5 [xx](../../public/example/1.vue3.base/xx)

```js

```

## 2

### 2.1 [xx](../../public/example/1.vue3.base/xx)

```ts

```

### 2.2 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 2.3 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 2.4 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 2.5 [xx](../../public/example/1.vue3.base/xx)

```js

```

## 3

### 3.1 [xx](../../public/example/1.vue3.base/xx)

```ts

```

### 3.2 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 3.3 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 3.4 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 3.5 [xx](../../public/example/1.vue3.base/xx)

```js

```

## 4

### 4.1 [xx](../../public/example/1.vue3.base/xx)

```ts

```

### 4.2 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 4.3 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 4.4 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 4.5 [xx](../../public/example/1.vue3.base/xx)

```js

```

## 5

### 5.1 [xx](../../public/example/1.vue3.base/xx)

```ts

```

### 5.2 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 5.3 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 5.4 [xx](../../public/example/1.vue3.base/xx)

```js

```

### 5.5 [xx](../../public/example/1.vue3.base/xx)

```js

```
